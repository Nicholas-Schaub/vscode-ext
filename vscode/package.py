# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/SchemaStore/schemastore/master/src/schemas/json/package.json
#   timestamp: 2022-01-09T19:11:31+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, EmailStr, Extra, Field, constr


class Bugs(BaseModel):
    url: Optional[AnyUrl] = Field(
        None, description="The url to your project's issue tracker."
    )
    email: Optional[EmailStr] = Field(
        None, description='The email address to which issues should be reported.'
    )


class License(BaseModel):
    type: Optional[str] = None
    url: Optional[AnyUrl] = None


class Type(Enum):
    commonjs = 'commonjs'
    module = 'module'


class TypesVersions(BaseModel):
    class Config:
        extra = Extra.forbid

    _: Optional[List[constr(regex=r'^[^*]*(?:\*[^*]*)?$')]] = Field(
        None,
        alias='*',
        description='Maps all file paths to the file paths specified in the array.',
    )


class Directories(BaseModel):
    bin: Optional[str] = Field(
        None,
        description="If you specify a 'bin' directory, then all the files in that folder will be used as the 'bin' hash.",
    )
    doc: Optional[str] = Field(
        None,
        description='Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.',
    )
    example: Optional[str] = Field(
        None,
        description='Put example scripts in here. Someday, it might be exposed in some clever way.',
    )
    lib: Optional[str] = Field(
        None,
        description="Tell people where the bulk of your library is. Nothing special is done with the lib folder in any way, but it's useful meta info.",
    )
    man: Optional[str] = Field(
        None,
        description="A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.",
    )
    test: Optional[str] = None


class Repository(BaseModel):
    type: Optional[str] = None
    url: Optional[str] = None
    directory: Optional[str] = None


class PeerDependenciesMeta(BaseModel):
    class Config:
        extra = Extra.allow

    optional: Optional[bool] = Field(
        None,
        description='Specifies that this peer dependency is optional and should not be installed automatically.',
    )


class Engines(BaseModel):
    class Config:
        extra = Extra.allow

    node: Optional[str] = None


class PrivateEnum(Enum):
    false = 'false'
    true = 'true'


class Access(Enum):
    public = 'public'
    restricted = 'restricted'


class PublishConfig(BaseModel):
    class Config:
        extra = Extra.allow

    access: Optional[Access] = None
    tag: Optional[str] = None
    registry: Optional[AnyUrl] = None


class Dist(BaseModel):
    shasum: Optional[str] = None
    tarball: Optional[str] = None


class Esnext(BaseModel):
    class Config:
        extra = Extra.allow

    main: Optional[str] = None
    browser: Optional[str] = None


class Workspace(BaseModel):
    packages: Optional[List[str]] = Field(
        None, description='Workspace package paths. Glob patterns are supported.'
    )
    nohoist: Optional[List[str]] = Field(
        None,
        description='Packages to block from hoisting to the workspace root. Currently only supported in Yarn only.',
    )


class Person(BaseModel):
    name: str
    url: Optional[AnyUrl] = None
    email: Optional[EmailStr] = None


class Dependency(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class ScriptsInstallAfter(BaseModel):
    __root__: str = Field(..., description='Run AFTER the package is installed.')


class ScriptsPublishAfter(BaseModel):
    __root__: str = Field(..., description='Run AFTER the package is published.')


class ScriptsRestart(BaseModel):
    __root__: str = Field(
        ...,
        description="Run by the 'npm restart' command. Note: 'npm restart' will run the stop and start scripts if no restart script is provided.",
    )


class ScriptsStart(BaseModel):
    __root__: str = Field(..., description="Run by the 'npm start' command.")


class ScriptsStop(BaseModel):
    __root__: str = Field(..., description="Run by the 'npm stop' command.")


class ScriptsTest(BaseModel):
    __root__: str = Field(..., description="Run by the 'npm test' command.")


class ScriptsUninstallBefore(BaseModel):
    __root__: str = Field(..., description='Run BEFORE the package is uninstalled.')


class ScriptsVersionBefore(BaseModel):
    __root__: str = Field(..., description='Run BEFORE bump the package version.')


class PackageExportsEntryPath(BaseModel):
    __root__: Optional[constr(regex=r'^\./')] = Field(
        ...,
        description='The module path that is resolved when this specifier is imported. Set to `null` to disallow importing this module.',
    )


class Scripts(BaseModel):
    class Config:
        extra = Extra.allow

    lint: Optional[str] = Field(
        None, description='Run code quality tools, e.g. ESLint, TSLint, etc.'
    )
    prepublish: Optional[str] = Field(
        None,
        description='Run BEFORE the package is published (Also run on local npm install without any arguments).',
    )
    prepare: Optional[str] = Field(
        None,
        description='Run both BEFORE the package is packed and published, and on local npm install without any arguments. This is run AFTER prepublish, but BEFORE prepublishOnly.',
    )
    prepublishOnly: Optional[str] = Field(
        None,
        description='Run BEFORE the package is prepared and packed, ONLY on npm publish.',
    )
    prepack: Optional[str] = Field(
        None,
        description='run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies).',
    )
    postpack: Optional[str] = Field(
        None,
        description='Run AFTER the tarball has been generated and moved to its final destination.',
    )
    publish: Optional[str] = Field(
        None,
        description='Publishes a package to the registry so that it can be installed by name. See https://docs.npmjs.com/cli/v8/commands/npm-publish',
    )
    postpublish: Optional[ScriptsPublishAfter] = None
    preinstall: Optional[str] = Field(
        None, description='Run BEFORE the package is installed.'
    )
    install: Optional[ScriptsInstallAfter] = None
    postinstall: Optional[ScriptsInstallAfter] = None
    preuninstall: Optional[ScriptsUninstallBefore] = None
    uninstall: Optional[ScriptsUninstallBefore] = None
    postuninstall: Optional[str] = Field(
        None, description='Run AFTER the package is uninstalled.'
    )
    preversion: Optional[ScriptsVersionBefore] = None
    version: Optional[ScriptsVersionBefore] = None
    postversion: Optional[str] = Field(
        None, description='Run AFTER bump the package version.'
    )
    pretest: Optional[ScriptsTest] = None
    test: Optional[ScriptsTest] = None
    posttest: Optional[ScriptsTest] = None
    prestop: Optional[ScriptsStop] = None
    stop: Optional[ScriptsStop] = None
    poststop: Optional[ScriptsStop] = None
    prestart: Optional[ScriptsStart] = None
    start: Optional[ScriptsStart] = None
    poststart: Optional[ScriptsStart] = None
    prerestart: Optional[ScriptsRestart] = None
    restart: Optional[ScriptsRestart] = None
    postrestart: Optional[ScriptsRestart] = None
    serve: Optional[str] = Field(
        None, description='Start dev server to serve application files'
    )


class Export(BaseModel):
    class Config:
        extra = Extra.forbid

    _: Optional[PackageExportsEntryOrFallback] = Field(
        None,
        alias='.',
        description='The module path that is resolved when the module specifier matches "name", shadows the "main" field.',
    )


class JsonSchemaForNpmPackageJsonFiles(BaseModel):
    name: Optional[
        constr(
            regex=r'^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$',
            min_length=1,
            max_length=214,
        )
    ] = Field(None, description='The name of the package.')
    version: Optional[str] = Field(
        None,
        description='Version must be parseable by node-semver, which is bundled with npm as a dependency.',
    )
    description: Optional[str] = Field(
        None,
        description="This helps people discover your package, as it's listed in 'npm search'.",
    )
    keywords: Optional[List[str]] = Field(
        None,
        description="This helps people discover your package as it's listed in 'npm search'.",
    )
    homepage: Optional[str] = Field(
        None, description='The url to the project homepage.'
    )
    bugs: Optional[Bugs] = Field(
        None,
        description="The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.",
    )
    license: Optional[str] = Field(
        None,
        description="You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.",
    )
    licenses: Optional[List[License]] = Field(
        None,
        description='DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or { "license": "(MIT OR Apache-2.0)" } see: \'https://docs.npmjs.com/files/package.json#license\'.',
    )
    author: Optional[Person] = None
    contributors: Optional[List[Person]] = Field(
        None, description='A list of people who contributed to this package.'
    )
    maintainers: Optional[List[Person]] = Field(
        None, description='A list of people who maintains this package.'
    )
    files: Optional[List[str]] = Field(
        None,
        description="The 'files' field is an array of files to include in your project. If you name a folder in the array, then it will also include the files inside that folder.",
    )
    main: Optional[str] = Field(
        None,
        description='The main field is a module ID that is the primary entry point to your program.',
    )
    exports: Optional[
        Union[
            PackageExportsEntryPath,
            Export,
            PackageExportsEntryObject,
            PackageExportsFallback,
        ]
    ] = Field(
        None,
        description='The "exports" field is used to restrict external access to non-exported module files, also enables a module to import itself using "name".',
    )
    bin: Optional[Union[str, Dict[str, Any]]] = None
    type: Optional[Type] = Field(
        'commonjs',
        description='When set to "module", the type field allows a package to specify all .js files within are ES modules. If the "type" field is omitted or set to "commonjs", all .js files are treated as CommonJS.',
    )
    types: Optional[str] = Field(
        None,
        description='Set the types property to point to your bundled declaration file.',
    )
    typings: Optional[str] = Field(
        None,
        description='Note that the "typings" field is synonymous with "types", and could be used as well.',
    )
    typesVersions: Optional[Dict[str, TypesVersions]] = Field(
        None,
        description='The "typesVersions" field is used since TypeScript 3.1 to support features that were only made available in newer TypeScript versions.',
    )
    man: Optional[List[str]] = Field(
        None,
        description='Specify either a single file or an array of filenames to put in place for the man program to find.',
    )
    directories: Optional[Directories] = None
    repository: Optional[Repository] = Field(
        None,
        description='Specify the place where your code lives. This is helpful for people who want to contribute.',
    )
    scripts: Optional[Scripts] = Field(
        None,
        description="The 'scripts' member is an object hash of script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.",
    )
    config: Optional[Dict[str, Any]] = Field(
        None,
        description="A 'config' hash can be used to set configuration parameters used in package scripts that persist across upgrades.",
    )
    dependencies: Optional[Dependency] = None
    devDependencies: Optional[Dependency] = None
    optionalDependencies: Optional[Dependency] = None
    peerDependencies: Optional[Dependency] = None
    peerDependenciesMeta: Optional[Dict[str, PeerDependenciesMeta]] = Field(
        None,
        description='When a user installs your package, warnings are emitted if packages specified in "peerDependencies" are not already installed. The "peerDependenciesMeta" field serves to provide more information on how your peer dependencies are utilized. Most commonly, it allows peer dependencies to be marked as optional. Metadata for this field is specified with a simple hash of the package name to a metadata object.',
    )
    bundledDependencies: Optional[Union[List[str], bool]] = Field(
        None,
        description='Array of package names that will be bundled when publishing the package.',
    )
    bundleDependencies: Optional[Union[List[str], bool]] = Field(
        None,
        description='DEPRECATED: This field is honored, but "bundledDependencies" is the correct field name.',
    )
    resolutions: Optional[Dict[str, Any]] = Field(
        None,
        description='Resolutions is used to support selective version resolutions, which lets you define custom package versions or ranges inside your dependencies. See: https://classic.yarnpkg.com/en/docs/selective-version-resolutions',
    )
    packageManager: Optional[
        constr(regex=r'(npm|pnpm|yarn)@\d+\.\d+\.\d+(-.+)?')
    ] = Field(
        None,
        description='Defines which package manager is expected to be used when working on the current project. This field is currently experimental and needs to be opted-in; see https://nodejs.org/api/corepack.html',
    )
    engines: Optional[Engines] = None
    engineStrict: Optional[bool] = None
    os: Optional[List[str]] = Field(
        None, description='Specify which operating systems your module will run on.'
    )
    cpu: Optional[List[str]] = Field(
        None,
        description='Specify that your code only runs on certain cpu architectures.',
    )
    preferGlobal: Optional[bool] = Field(
        None,
        description='DEPRECATED: This option used to trigger an npm warning, but it will no longer warn. It is purely there for informational purposes. It is now recommended that you install any binaries as local devDependencies wherever possible.',
    )
    private: Optional[Union[bool, PrivateEnum]] = Field(
        None, description='If set to true, then npm will refuse to publish it.'
    )
    publishConfig: Optional[PublishConfig] = None
    dist: Optional[Dist] = None
    readme: Optional[str] = None
    module: Optional[str] = Field(
        None,
        description='An ECMAScript module ID that is the primary entry point to your program.',
    )
    esnext: Optional[Esnext] = Field(
        None,
        description='A module ID with untranspiled code that is the primary entry point to your program.',
    )
    workspaces: Optional[Union[List[str], Workspace]] = Field(
        None,
        description='Allows packages within a directory to depend on one another using direct linking of local files. Additionally, dependencies within a workspace are hoisted to the workspace root when possible to reduce duplication. Note: It\'s also a good idea to set "private" to true when using this feature.',
    )
    jspm: Optional[JsonSchemaForNpmPackageJsonFiles] = None


class PackageExportsEntryObject(BaseModel):
    class Config:
        extra = Extra.forbid

    require: Optional[PackageExportsEntryOrFallback] = Field(
        None,
        description='The module path that is resolved when this specifier is imported as a CommonJS module using the `require(...)` function.',
    )
    import_: Optional[PackageExportsEntryOrFallback] = Field(
        None,
        alias='import',
        description='The module path that is resolved when this specifier is imported as an ECMAScript module using an `import` declaration or the dynamic `import(...)` function.',
    )
    node: Optional[PackageExportsEntryOrFallback] = Field(
        None,
        description='The module path that is resolved when this environment is Node.js.',
    )
    default: Optional[PackageExportsEntryOrFallback] = Field(
        None,
        description='The module path that is resolved when no other export type matches.',
    )


class PackageExportsEntry(BaseModel):
    __root__: Union[PackageExportsEntryPath, PackageExportsEntryObject]


class PackageExportsFallback(BaseModel):
    __root__: List[PackageExportsEntry] = Field(
        ...,
        description="Used to allow fallbacks in case this environment doesn't support the preceding entries.",
    )


class PackageExportsEntryOrFallback(BaseModel):
    __root__: Union[PackageExportsEntry, PackageExportsFallback]


Export.update_forward_refs()
JsonSchemaForNpmPackageJsonFiles.update_forward_refs()
PackageExportsEntryObject.update_forward_refs()
